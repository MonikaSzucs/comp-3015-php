# Class 7
- PHPUnit
- DotEnv
- semantic versioning

composer init
- package name is a ventor
[cfenn/in-class-example]: 

## Setup
PS C:\Users\mszuc> cd desktop
PS C:\Users\mszuc\desktop> mkdir example


    Directory: C:\Users\mszuc\desktop


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        2024-06-10   6:24 PM                example


PS C:\Users\mszuc\desktop> cd example
PS C:\Users\mszuc\desktop\example> composer init 

                                            
  Welcome to the Composer config generator  
                                            


This command will guide you through creating your composer.json config.

Package name (<vendor>/<name>) [mszuc/example]:
Description []:
Author [Monika Szucs <monika.szucs.work@gmail.com>, n to skip]:
Minimum Stability []:
Package Type (e.g. library, project, metapackage, composer-plugin) []: project
License []: MIT

Define your dependencies.

Would you like to define your dependencies (require) interactively [yes]? no     
Would you like to define your dev dependencies (require-dev) interactively [yes]? no
Add PSR-4 autoload mapping? Maps namespace "Mszuc\Example" to the entered relative path. [src/, n to skip]: 

{
    "name": "mszuc/example",
    "type": "project",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Mszuc\\Example\\": "src/"
        }
    },
    "authors": [
        {
            "name": "Monika Szucs",
            "email": "monika.szucs.work@gmail.com"
        }
    ],
    "require": {}
}

Do you confirm generation [yes]?
Generating autoload files
Generated autoload files
PSR-4 autoloading configured. Use "namespace Mszuc\Example;" in src/
Include the Composer autoloader with: require 'vendor/autoload.php';
PS C:\Users\mszuc\desktop\example> 


# third party php code to install

- we are interacting with package repository
php packages are hosted like in [packagist.org](packagist.org)
- search for http client
guzzlehttp/guzzle
- there is a link to their github and it will show you how to use it

in termal install:
composer require guzzlehttp/guzzle

# Notes PowerPoint
## Getting Started with composer
Navigate to: https://getcomposer.org/download/ and follow the download instructions.

## Getting started with composer: Initialization
Getting started with Composer: initialization

```
composer init
```
After running composer init we’ll have a composer.json file that looks similar to:

## Getting started with composer: require packages
Composer can be used to install packages from a repository such as Packagist
Example: we need to write some tests for our application.
PHPUnit is on Packagist and can be installed using Composer:

```
composer require --dev phpunit/phpunit ^9.5
```

The composer.json file updates to require the phpunit package.
A vendor/ folder will also be created that contains the code for your required dependencies.

## Composer: require-dev
- Some dependencies are only needed in development and/or testing
environments.
- These dependencies should be installed using the --dev flag (e.g. phpunit,
previous slide)
- In a production environment a deployment script would run
-- composer install --no-dev # ignores dependencies in require-dev

- Continuing from the previous slide, PHPUnit ^9.5 is in our composer.json file.
- This means we’re requesting PHPUnit has: 9.5.0 <= version < 10.0.0
See: https://getcomposer.org/doc/articles/versions.md#caret-version-range

## Semantic Versioning
MAJOR.MINOR.PATCH
MAJOR: API changes, incompatible with previous versions
MINOR: functionality added, backwards compatible
PATCH: backwards compatible bug fix
Packages don’t have to follow this, but many do. It makes dependency management
easier.

## Getting started with Composer. The lock file
`composer.lock` is automatically generated by composer.
It should be committed to version control.
It guarantees that all developers running $ composer install will get the exact same
versions of dependencies.
- Important because versions are specified as ranges in composer.json
-- Example:
https://getcomposer.org/doc/articles/versions.md#caret-version-range

## Getting started with Composer: Additional Commands
$ composer init # create a composer.json file
$ composer require # add a package to the composer.json file and install it
$ composer install # read the composer.json file and install pkgs to the
→ if there’s a lock file, use exact versions specified
$ composer update # upgrades packages to the newest allowed versions
$ composer audit # check for security vulnerabilities
$ composer remove # removes a package from composer.json and vendor/
Check docs for more: https://getcomposer.org/doc/03-cli.md

## Importing required dependencies autoloading
https://getcomposer.org/doc/01-basic-usage.md#autoloading
- Autoloading allows us to automatically load and use PHP classes without explicitly using require/require_once/include/include_once
Composer generates a vendor/autoload.php file that can be used to include packages.
How does this work though? See: spl_autoload_register_example.zip

## Autoloading take away
- When PHP encounters a class that is unknown, there is a mechanism to
resolve the dependency that we, as developers, have control over.
- We don’t need to explicitly import/require each class (of our own, or from
dependencies).
-- We’ll see more of this when we learn about PSR-4 Autoloading
- Rarely will you use the spl_autoload_register function
-- Often we use a library or framework that provides an abstraction

## Dependency Security Vulnerabilities
- Dependencies that your application requires can contain security vulnerabilities.
-- Example: https://en.wikipedia.org/wiki/Log4Shell
- As a developer consuming these packages, you need to know how to check for security vulnerabilities and fix them
-- From a consumer point of view, fixes are done by upgrading to a patched version of the package

- Check for vulnerabilities: $ composer audit
- Fixing vulnerable dependencies as a consumer of those dependencies: search for an updated version of the package and install it in your application.
- If you found a vulnerability in a package your application is using and then later found a patched release of the package, you could install the patched version using:
```
$ composer update <package>
…or $ composer require <package>:<version>
```

## Testing with PHPUnit
Lab example.
Testing tips:
- Test one method at a time
- One test should not be dependent on another test
-- Dependent tests can make it challenging to isolate problems when
failures occur
- Check return values, make assertions based on them
- Use setUp and tearDown methods to get the pre-test and post-test state
that you need (see: https://docs.phpunit.de/en/11.2/fixtures.html)

## Dependency Management:
● Where does composer search for packages (by default)?
- composer will create a composer.json file. Composer will look up a package up on Packagist.org unless you specify otherwise.

● When is spl_autoload_register called?
PHP needs to access a class that has not been defined.

● What is semantic versioning?
Given a version number MAJOR.MINOR.PATCH, increment the:

MAJOR version when you make incompatible API changes
MINOR version when you add functionality in a backward compatible manner
PATCH version when you make backward compatible bug fixes
Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.

- How can we check for security vulnerabilities in 3rd party packages?
composer audit
From a consumer point of view, fixes are done by upgrading to a patched version of the package


- If a package we’re using has a security vulnerability, what should we do?
If you found a vulnerability in a package your application is using and then later found a patched release of the package, you could install the patched version using:
$ composer update <package>
…or $ composer require <package>:<version>


- Why should the composer.lock file be used, what does it do?
composer.lock is automatically generated by composer.
It should be committed to version control.
It guarantees that all developers running $ composer install will get the exact same versions of dependencies.
